---
layout: posts
title: "Front End"
categories: ["Compiler"]
---


### Traditional Two-pass Compiler

Source code → Front End → IR (중간 표현) → Back End → Machine Code

- Front End, Back End 모두에서 errors 를 보고할 수 있다.

<img width="1690" height="380" alt="image" src="https://github.com/user-attachments/assets/38dc0052-3dec-419f-80ec-4dc51d0f2609" />

**two-pass**

- Front-End: 소스 코드를 읽어서 의미 있는 내부 형태 (IR) 로 바꾼다.
- Back-End: IR 을 바탕으로 실제 실행 가능한 기계어를 만드나.

**High level functions**

컴파일러의 큰 목표:

1. 합법적인(문법/의미가 맞는) 프로그램인지 인식하고, OS/linker 가 받아들일 수 있는 정상적인 코드 생성
2. 변수/함수/코드가 메모리 어디에 놓일지 같은 저장(메모리) 관리까지 처리

**IR (Intermediate Representation) 란 ?**

source language (java, C … )와 기계어 사이의 중간 언어 / 자료 구조

→ front/back 을 분리하여 확장과 최적화가 쉽다.

<img width="1754" height="418" alt="image" src="https://github.com/user-attachments/assets/a02a557c-4690-4a05-aa74-1f8178dea794" />

### Scanner (Lexical Analysis, 어휘 분석기)

: 소스 코드를 글자 단위로 읽어서 token으로 쪼갠다.

ex) int, x, =, 3, ;

### Parser (Syntax Analysis, 구문 분석기)

: token 들의 나열이 문법 규칙에 맞는지 검사하고 보통 Parse tree / AST 같은 구조를 만든 뒤 다음 단걔가 쓰기 좋은 형태로 IR 생성에 필요한 뼈대를 준비한다.

**Front End 의 Responsibilities**

- recognize legal programs
    - 문법적으로/의미적으로 맞는 코드인지 판단
- report errors in a useful way
    - 어디 줄 몇 번째에서 뭐가 잘못됐는지
- produce IR & preliminary storage map
    - IR 만들기 + 심볼 테이블 / 스코프 / 타입정보 같은 초기 메모리 / 식별자 매핑
- shape the code for the back end
    - Back End 가 최적화 / 코드 생성하기 좋게 정리
- much of front end construction can be automated
    - Scanner / Parser 는 규칙 기반이라 도구로 자동 생성 가능
